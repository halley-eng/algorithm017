学习笔记 数组 与 链表

## 数组篇

***为什么很多编程语言中数组都从0开始编号***

### 什么是数组

> 数组(Array) 是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据结构。

1. 线性表 
2. 连续的内存空间和相同数据类型

以上两点的限制带来的利弊:
+ 杀手锏特性——**随机访问**
+ 低效的插入和删除

### 随机访问

> 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。

寻址公式：```a[i]_address = base_address + i * data_type_size```
> data_type_size表示数组中每个元素的大小，若int数组，data_type_size就为4个字节。

~~错误认识: 数组的查询操作时间复杂度为O(1)~~  
**正确表述: 数组支持随机访问，根据下标随机访问的时间复杂度为O(1)**

### 低效的“插入”和“删除”

> 为了保证数组的连续性，需要做大量的数据搬移工作
#### 插入优化
前提：数组只是被当作一个存储数据的集合，为了避免大规模的数据搬移。简单办法：  
直接将第k位数据搬移到数组元素的最后，把新的元素直接放入第k个位置。

#### 删除优化
在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。  
每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作。(JVM标记清除垃圾回收算法的核心思想)

### 警惕数组的访问越界问题
**越界检查**

### 容器能否完全替代数组

以Java语言为例 

1. Java ArrayList 无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 当要表示多维数组时，用数组往往更直观。

**Summary**  
**对于业务开发，直接使用容器就足够了。非常底层的开发，性能的优化需要做到极致，这时候数组优于容器。**

### 为什么数组从 0 开始编号

1. 从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。
2. 历史原因


---------------------------------------------------------------------------

## 链表篇

相比数组，链表是一种稍微复杂的数据结构。两个都是非常基础、非常常用的数据结构。  

> 写链表代码是最考验逻辑思维能力的

### 链表 VS 数组
1. 底层存储结构：数组需要一块连续的内存空间，链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来。
2. 因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反

![数组 VS 链表](https://cdn.jsdelivr.net/gh/stupid-yu/cdn/img/algorithm/Array_Linkedlist.jpg)


### 三种常见链表结构
1. 单链表
2. 双向链表
3. 循环链表

#### 单链表
单链表有两个结点是比较特殊的，我们习惯把第一个结点叫做头结点，把最后一个结点叫做尾结点。其中，头结点用来记录链表的基地址，尾结点指向一个空地址 NULL，表示这是链表的最后一个结点。

#### 循环链表
循环链表是一种特殊的单链表，区别与单链表，循环链表的尾结点指针是指向链表的头结点。

#### 双向链表 
> 空间换时间的设计思想

双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

### 链表代码技巧

1. [理解指针或引用的含义](####理解指针或引用的含义)
2. [警惕指针丢失和内存泄漏](####警惕指针丢失和内存泄漏（单链表）)
3. [利用哨兵简化实现难度](####利用"哨兵"简化实现难度)
4. [重点留意边界条件处理](####重点留意边界条件处理)
5. 举例画图，辅助思考
6. 多写多练，没有捷径

#### 理解指针或引用的含义

将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。

```c
p—>next = q; //表示p节点的后继指针存储了q节点的内存地址。
p—>next = p—>next—>next; //表示p节点的后继指针存储了p节点的下下个节点的内存地址。
```

#### 警惕指针丢失和内存泄漏（单链表）

##### 插入节点

在节点a和节点b之间插入节点x，b是a的下一节点。

```c
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；
```

p->next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x->next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。正确的写法是2句代码交换顺序，即：

```c
x—>next = p—>next;
p—>next = x;
```

##### 删除节点
在节点a和节点b之间删除节点b，b是a的下一节点。

```c
p—>next = p—>next—>next;
```

#### 利用“哨兵”简化实现难度
链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。
***未引入“哨兵”的情况***，如果在p节点后插入一个节点，只需2行代码即可搞定：

```c
new_node—>next = p—>next;
p—>next = new_node;
```

但，若向空链表中插入一个节点，则代码如下：

```c
if(head == null){
	head = new_node;
}
```

如果要删除节点p的后继节点，只需1行代码即可搞定：

```c
p—>next = p—>next—>next;
```

但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：

```c
if(head—>next == null){
	head = null;
}
```

从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

***引入“哨兵”的情况***，“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

#### 重点留意边界条件处理
经常用来检查链表是否正确的边界4个边界条件：

1. 如果链表为空时，代码是否能正常工作？
2. 如果链表只包含一个节点时，代码是否能正常工作？
3. 如果链表只包含两个节点时，代码是否能正常工作？
4. 代码逻辑在处理头尾节点时是否能正常工作？

### 5 个常见的链表操作

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点